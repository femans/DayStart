create table "public"."cost_registration" (
    "created_at" timestamp with time zone not null default now(),
    "money" double precision not null default '0'::double precision,
    "user" uuid default auth.uid(),
    "currency" text,
    "description" text,
    "document_url" text,
    "plan" uuid not null,
    "uuid" uuid not null default gen_random_uuid()
);


alter table "public"."cost_registration" enable row level security;

create table "public"."plan_dependencies" (
    "created_by" uuid not null default auth.uid(),
    "plan" uuid not null,
    "depends_on" uuid not null,
    "uuid" uuid not null default gen_random_uuid()
);


alter table "public"."plan_dependencies" enable row level security;

create table "public"."plans" (
    "created_at" timestamp with time zone not null default now(),
    "title" text default ''::text,
    "definition_of_done" text default ''::text,
    "done" boolean not null default false,
    "assignee_id" uuid not null,
    "budget" real,
    "manhours_required" real,
    "archived" boolean not null default false,
    "priority" real not null,
    "id" bigint generated by default as identity not null,
    "created_by" uuid not null default auth.uid(),
    "done_date" timestamp with time zone,
    "archived_date" timestamp with time zone,
    "assigned_by" uuid default auth.uid(),
    "documentation_url" text,
    "uuid" uuid not null default gen_random_uuid(),
    "nanoid" text,
    "parent" uuid
);


alter table "public"."plans" enable row level security;

create table "public"."time_registration" (
    "created_at" timestamp with time zone not null default now(),
    "hours" double precision not null default '0'::double precision,
    "user" uuid default auth.uid(),
    "description" text,
    "plan" uuid not null,
    "uuid" uuid not null default gen_random_uuid()
);


alter table "public"."time_registration" enable row level security;

CREATE UNIQUE INDEX "Plans_id_key" ON public.plans USING btree (id);

CREATE UNIQUE INDEX cost_registration_pkey ON public.cost_registration USING btree (uuid);

CREATE UNIQUE INDEX cost_registration_uuid_key ON public.cost_registration USING btree (uuid);

CREATE UNIQUE INDEX plan_dependencies_pkey ON public.plan_dependencies USING btree (uuid);

CREATE UNIQUE INDEX plans_pkey ON public.plans USING btree (uuid, id);

CREATE UNIQUE INDEX plans_uid_key ON public.plans USING btree (uuid);

CREATE UNIQUE INDEX time_registration_uuid_key ON public.time_registration USING btree (uuid);

alter table "public"."cost_registration" add constraint "cost_registration_pkey" PRIMARY KEY using index "cost_registration_pkey";

alter table "public"."plan_dependencies" add constraint "plan_dependencies_pkey" PRIMARY KEY using index "plan_dependencies_pkey";

alter table "public"."plans" add constraint "plans_pkey" PRIMARY KEY using index "plans_pkey";

alter table "public"."cost_registration" add constraint "cost_registration_plan_fkey" FOREIGN KEY (plan) REFERENCES plans(uuid) not valid;

alter table "public"."cost_registration" validate constraint "cost_registration_plan_fkey";

alter table "public"."cost_registration" add constraint "cost_registration_user_fkey" FOREIGN KEY ("user") REFERENCES auth.users(id) not valid;

alter table "public"."cost_registration" validate constraint "cost_registration_user_fkey";

alter table "public"."cost_registration" add constraint "cost_registration_user_fkey1" FOREIGN KEY ("user") REFERENCES auth.users(id) not valid;

alter table "public"."cost_registration" validate constraint "cost_registration_user_fkey1";

alter table "public"."cost_registration" add constraint "cost_registration_uuid_key" UNIQUE using index "cost_registration_uuid_key";

alter table "public"."plan_dependencies" add constraint "plan_dependencies_depends_on_uuid_fkey" FOREIGN KEY (depends_on) REFERENCES plans(uuid) not valid;

alter table "public"."plan_dependencies" validate constraint "plan_dependencies_depends_on_uuid_fkey";

alter table "public"."plan_dependencies" add constraint "plan_dependencies_plan_uuid_fkey" FOREIGN KEY (plan) REFERENCES plans(uuid) not valid;

alter table "public"."plan_dependencies" validate constraint "plan_dependencies_plan_uuid_fkey";

alter table "public"."plans" add constraint "Plans_id_key" UNIQUE using index "Plans_id_key";

alter table "public"."plans" add constraint "Plans_responsible_fkey" FOREIGN KEY (assignee_id) REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."plans" validate constraint "Plans_responsible_fkey";

alter table "public"."plans" add constraint "plans_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."plans" validate constraint "plans_created_by_fkey";

alter table "public"."plans" add constraint "plans_parent_fkey" FOREIGN KEY (parent) REFERENCES plans(uuid) not valid;

alter table "public"."plans" validate constraint "plans_parent_fkey";

alter table "public"."plans" add constraint "plans_uid_key" UNIQUE using index "plans_uid_key";

alter table "public"."time_registration" add constraint "time_registration_plan_uuid_fkey" FOREIGN KEY (plan) REFERENCES plans(uuid) not valid;

alter table "public"."time_registration" validate constraint "time_registration_plan_uuid_fkey";

alter table "public"."time_registration" add constraint "time_registration_user_fkey" FOREIGN KEY ("user") REFERENCES auth.users(id) not valid;

alter table "public"."time_registration" validate constraint "time_registration_user_fkey";

alter table "public"."time_registration" add constraint "time_registration_user_fkey1" FOREIGN KEY ("user") REFERENCES auth.users(id) not valid;

alter table "public"."time_registration" validate constraint "time_registration_user_fkey1";

alter table "public"."time_registration" add constraint "time_registration_uuid_key" UNIQUE using index "time_registration_uuid_key";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.set_archived_date()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$BEGIN
    IF NEW.archived = TRUE AND (OLD.archived IS DISTINCT FROM NEW.archived) THEN
        NEW.archived_date := NOW();
    END IF;
    RETURN NEW;
END;$function$
;

CREATE OR REPLACE FUNCTION public.set_done_date()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    IF NEW.done = TRUE AND (OLD.done IS DISTINCT FROM NEW.done) THEN
        NEW.done_date := NOW();
    END IF;
    RETURN NEW;
END;
$function$
;

grant delete on table "public"."cost_registration" to "anon";

grant insert on table "public"."cost_registration" to "anon";

grant references on table "public"."cost_registration" to "anon";

grant select on table "public"."cost_registration" to "anon";

grant trigger on table "public"."cost_registration" to "anon";

grant truncate on table "public"."cost_registration" to "anon";

grant update on table "public"."cost_registration" to "anon";

grant delete on table "public"."cost_registration" to "authenticated";

grant insert on table "public"."cost_registration" to "authenticated";

grant references on table "public"."cost_registration" to "authenticated";

grant select on table "public"."cost_registration" to "authenticated";

grant trigger on table "public"."cost_registration" to "authenticated";

grant truncate on table "public"."cost_registration" to "authenticated";

grant update on table "public"."cost_registration" to "authenticated";

grant delete on table "public"."cost_registration" to "service_role";

grant insert on table "public"."cost_registration" to "service_role";

grant references on table "public"."cost_registration" to "service_role";

grant select on table "public"."cost_registration" to "service_role";

grant trigger on table "public"."cost_registration" to "service_role";

grant truncate on table "public"."cost_registration" to "service_role";

grant update on table "public"."cost_registration" to "service_role";

grant delete on table "public"."plan_dependencies" to "anon";

grant insert on table "public"."plan_dependencies" to "anon";

grant references on table "public"."plan_dependencies" to "anon";

grant select on table "public"."plan_dependencies" to "anon";

grant trigger on table "public"."plan_dependencies" to "anon";

grant truncate on table "public"."plan_dependencies" to "anon";

grant update on table "public"."plan_dependencies" to "anon";

grant delete on table "public"."plan_dependencies" to "authenticated";

grant insert on table "public"."plan_dependencies" to "authenticated";

grant references on table "public"."plan_dependencies" to "authenticated";

grant select on table "public"."plan_dependencies" to "authenticated";

grant trigger on table "public"."plan_dependencies" to "authenticated";

grant truncate on table "public"."plan_dependencies" to "authenticated";

grant update on table "public"."plan_dependencies" to "authenticated";

grant delete on table "public"."plan_dependencies" to "service_role";

grant insert on table "public"."plan_dependencies" to "service_role";

grant references on table "public"."plan_dependencies" to "service_role";

grant select on table "public"."plan_dependencies" to "service_role";

grant trigger on table "public"."plan_dependencies" to "service_role";

grant truncate on table "public"."plan_dependencies" to "service_role";

grant update on table "public"."plan_dependencies" to "service_role";

grant delete on table "public"."plans" to "anon";

grant insert on table "public"."plans" to "anon";

grant references on table "public"."plans" to "anon";

grant select on table "public"."plans" to "anon";

grant trigger on table "public"."plans" to "anon";

grant truncate on table "public"."plans" to "anon";

grant update on table "public"."plans" to "anon";

grant delete on table "public"."plans" to "authenticated";

grant insert on table "public"."plans" to "authenticated";

grant references on table "public"."plans" to "authenticated";

grant select on table "public"."plans" to "authenticated";

grant trigger on table "public"."plans" to "authenticated";

grant truncate on table "public"."plans" to "authenticated";

grant update on table "public"."plans" to "authenticated";

grant delete on table "public"."plans" to "service_role";

grant insert on table "public"."plans" to "service_role";

grant references on table "public"."plans" to "service_role";

grant select on table "public"."plans" to "service_role";

grant trigger on table "public"."plans" to "service_role";

grant truncate on table "public"."plans" to "service_role";

grant update on table "public"."plans" to "service_role";

grant delete on table "public"."time_registration" to "anon";

grant insert on table "public"."time_registration" to "anon";

grant references on table "public"."time_registration" to "anon";

grant select on table "public"."time_registration" to "anon";

grant trigger on table "public"."time_registration" to "anon";

grant truncate on table "public"."time_registration" to "anon";

grant update on table "public"."time_registration" to "anon";

grant delete on table "public"."time_registration" to "authenticated";

grant insert on table "public"."time_registration" to "authenticated";

grant references on table "public"."time_registration" to "authenticated";

grant select on table "public"."time_registration" to "authenticated";

grant trigger on table "public"."time_registration" to "authenticated";

grant truncate on table "public"."time_registration" to "authenticated";

grant update on table "public"."time_registration" to "authenticated";

grant delete on table "public"."time_registration" to "service_role";

grant insert on table "public"."time_registration" to "service_role";

grant references on table "public"."time_registration" to "service_role";

grant select on table "public"."time_registration" to "service_role";

grant trigger on table "public"."time_registration" to "service_role";

grant truncate on table "public"."time_registration" to "service_role";

grant update on table "public"."time_registration" to "service_role";

create policy "delete_own_dependencies"
on "public"."plan_dependencies"
as permissive
for delete
to public
using ((EXISTS ( SELECT 1
   FROM plans p
  WHERE ((p.uuid = plan_dependencies.plan) AND (p.assignee_id = auth.uid())))));


create policy "insert_own_dependencies"
on "public"."plan_dependencies"
as permissive
for insert
to public
with check ((EXISTS ( SELECT 1
   FROM plans p
  WHERE ((p.uuid = plan_dependencies.plan) AND (p.assignee_id = auth.uid())))));


create policy "select_own_dependencies"
on "public"."plan_dependencies"
as permissive
for select
to public
using ((EXISTS ( SELECT 1
   FROM plans p
  WHERE ((p.uuid = plan_dependencies.plan) AND (p.assignee_id = auth.uid())))));


create policy "update_own_dependencies"
on "public"."plan_dependencies"
as permissive
for update
to public
using ((EXISTS ( SELECT 1
   FROM plans p
  WHERE ((p.uuid = plan_dependencies.plan) AND (p.assignee_id = auth.uid())))));


create policy "Enable delete for users based on user_id"
on "public"."plans"
as permissive
for delete
to public
using ((( SELECT auth.uid() AS uid) = assignee_id));


create policy "insert_own_records"
on "public"."plans"
as permissive
for insert
to public
with check ((assignee_id = auth.uid()));


create policy "select_own_records"
on "public"."plans"
as permissive
for select
to public
using ((assignee_id = auth.uid()));


create policy "update_own_records"
on "public"."plans"
as permissive
for update
to public
using ((assignee_id = auth.uid()));


CREATE TRIGGER trigger_set_archived_date BEFORE UPDATE ON public.plans FOR EACH ROW EXECUTE FUNCTION set_archived_date();

CREATE TRIGGER trigger_set_done_date BEFORE UPDATE OF done ON public.plans FOR EACH ROW EXECUTE FUNCTION set_done_date();



